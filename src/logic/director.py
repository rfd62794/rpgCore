"""
Autonomous Director - The "Dramatic Director" Controller

ADR 045: The "Dramatic Director" Controller

This service implements the autonomous intent system where the LLM acts as the "Subconscious"
that generates narrative beacons, and the Director orchestrates the Voyager's journey.

The Logic:
- LLM reviews 1,000-year history and decides on long-term goals
- Director generates narrative beacons (target coordinates) on the map
- Voyager pursues beacons deterministically using pathfinding
- Terminal acts as "subtitles" scrolling LLM observations
- GUI provides cinematic camera with focus management

This transforms the system from manual input to autonomous movie production.
"""

import asyncio
import time
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

from loguru import logger

from core.simulator import SimulatorHost, ActionResult
from core.intent_registry import IntentRegistry
from game_state import GameState


class NarrativeBeacon:
    """
    A narrative beacon represents an AI-generated goal location.
    
    The LLM generates these based on the 1,000-year history and current context.
    """
    
    def __init__(self, beacon_id: str, target_coords: Tuple[int, int], 
                 description: str, priority: int, intent_type: str):
        self.beacon_id = beacon_id
        self.target_coords = target_coords
        self.description = description
        self.priority = priority  # 1=highest, 10=lowest
        self.intent_type = intent_type  # "explore", "interact", "travel", "investigate"
        self.created_at = time.time()
        self.achieved = False


class DirectorMode(Enum):
    """Director operational modes."""
    IDLE = "idle"
    PLANNING = "planning"
    EXECUTING = "executing"
    PAUSED = "paused"
    CINEMATIC = "cinematic"


@dataclass
class DirectorIntent:
    """High-level intent generated by the LLM Director."""
    intent_type: str
    description: str
    target_coords: Optional[Tuple[int, int]] = None
    priority: int = 5
    reasoning: str = ""
    confidence: float = 0.0


class AutonomousDirector:
    """
    The Autonomous Director service.
    
    Acts as the bridge between LLM narrative generation and deterministic Voyager navigation.
    Generates narrative beacons and orchestrates the cinematic experience.
    """
    
    def __init__(self, simulator: SimulatorHost):
        self.simulator = simulator
        self.mode = DirectorMode.IDLE
        
        # Director state
        self.current_beacon: Optional[NarrativeBeacon] = None
        self.beacon_history: List[NarrativeBeacon] = []
        self.voyager_position: Tuple[int, int] = (0, 0)
        self.turn_count: int = 0  # Add turn counter as instance variable
        
        # Cinematic controls
        self.playback_speed = 1.0  # 1.0 = normal, 2.0 = fast, 0.5 = slow
        self.is_paused = False
        self.is_cinematic_mode = False
        
        # Director configuration
        self.beacon_generation_interval = 30  # Generate new beacon every 30 turns
        self.max_active_beacons = 3
        self.beacon_decay_time = 100  # Beacons expire after 100 turns
        
        # Event callbacks
        self.on_beacon_generated: Optional[Callable[[NarrativeBeacon], None]] = None
        self.on_beacon_achieved: Optional[Callable[[NarrativeBeacon], None]] = None
        self.on_cinematic_pause: Optional[Callable[[str], None]] = None
        
        logger.info("ðŸŽ¬ Autonomous Director initialized")
    
    async def start_autonomous_mode(self) -> None:
        """
        Start the autonomous director mode.
        
        The Director will begin generating narrative beacons and orchestrating
        the Voyager's journey autonomously.
        """
        logger.info("ðŸŽ¬ Starting Autonomous Director Mode")
        
        self.mode = DirectorMode.PLANNING
        self.is_cinematic_mode = True
        
        # Generate initial narrative beacons
        await self._generate_initial_beacons()
        
        # Start the director loop
        asyncio.create_task(self._director_loop())
    
    def pause_cinematic(self) -> None:
        """Pause the cinematic experience."""
        self.is_paused = True
        self.mode = DirectorMode.PAUSED
        
        if self.on_cinematic_pause:
            self.on_cinematic_pause("Cinematic paused by user")
        
        logger.info("â¸ï¸ Cinematic paused")
    
    def resume_cinematic(self) -> None:
        """Resume the cinematic experience."""
        self.is_paused = False
        self.mode = DirectorMode.EXECUTING
        
        if self.on_cinematic_pause:
            self.on_cinematic_pause("Cinematic resumed")
        
        logger.info("â–¶ï¸ Cinematic resumed")
    
    def set_playback_speed(self, speed: float) -> None:
        """Set the playback speed (0.5=slow, 1.0=normal, 2.0=fast)."""
        self.playback_speed = max(0.1, min(5.0, speed))
        logger.info(f"â©ï¸ Playback speed set to {self.playback_speed}x")
    
    def get_voyager_position(self) -> Tuple[int, int]:
        """Get the current Voyager position."""
        return self.voyager_position
    
    def get_current_beacon(self) -> Optional[NarrativeBeacon]:
        """Get the currently active narrative beacon."""
        return self.current_beacon
    
    def get_beacon_history(self) -> List['NarrativeBeacon']:
        """Get the history of all beacons."""
        return self.beacon_history
    
    async def _director_loop(self) -> None:
        """Main director loop for autonomous operation."""
        logger.info("ðŸŽ¬ Director loop started")
        
        try:
            while self.mode != DirectorMode.IDLE:
                if self.is_paused:
                    await asyncio.sleep(0.1)
                    continue
                
                # Execute based on current mode
                if self.mode == DirectorMode.PLANNING:
                    await self._planning_phase()
                elif self.mode == DirectorMode.EXECUTING:
                    await self._execution_phase()
                elif self.mode == DirectorMode.CINEMATIC:
                    await self._cinematic_phase()
                
                # Increment turn counter
                self.turn_count += 1
                
                # Control loop speed based on playback speed
                sleep_time = 1.0 / self.playback_speed
                await asyncio.sleep(sleep_time)
                
        except Exception as e:
            logger.error(f"âŒ Director loop error: {e}")
            self.mode = DirectorMode.IDLE
        finally:
            logger.info("ðŸŽ¬ Director loop stopped")
    
    async def _planning_phase(self) -> None:
        """Planning phase: Generate narrative beacons."""
        logger.debug("ðŸ“‹ Planning phase: Generating narrative beacons")
        
        # Generate new beacons periodically
        if len(self.beacon_history) == 0 or self.turn_count % self.beacon_generation_interval == 0:
            await self._generate_narrative_beacons()
        
        # Select highest priority beacon
        if self.beacon_history:
            active_beacons = [b for b in self.beacon_history if not b.achieved]
            if active_beacons:
                self.current_beacon = max(active_beacons, key=lambda b: b.priority)
                self.mode = DirectorMode.EXECUTING
                logger.info(f"ðŸŽ¯ Selected beacon: {self.current_beacon.description}")
        
        # If no beacons, generate emergency beacon
        if not self.current_beacon:
            await self._generate_emergency_beacon()
    
    async def _execution_phase(self) -> None:
        """Execution phase: Navigate to current beacon."""
        if not self.current_beacon:
            self.mode = DirectorMode.PLANNING
            return
        
        logger.debug(f"ðŸš¶ Executing phase: Moving to {self.current_beacon.target_coords}")
        
        # Calculate path to beacon
        path = self._calculate_path_to_beacon(self.voyager_position, self.current_beacon.target_coords)
        
        if not path:
            logger.warning(f"âŒ No path found to beacon {self.current_beacon.target_coords}")
            self.current_beacon.achieved = True
            if self.on_beacon_achieved:
                self.on_beacon_achieved(self.current_beacon)
            self.mode = DirectorMode.PLANNING
            return
        
        # Execute path step by step
        for i, next_pos in enumerate(path):
            if self.mode != DirectorMode.EXECUTING:
                break
            
            # Move Voyager to next position
            self.voyager_position = next_pos
            
            # Submit move action to simulator
            direction = self._get_direction_from_movement(self.voyager_position, next_pos)
            action_input = f"I move {direction}"
            
            # Submit action through simulator
            self.simulator.submit_action(action_input)
            
            # Wait for action processing
            await asyncio.sleep(0.5 / self.playback_speed)
            
            # Check if reached beacon
            if next_pos == self.current_beacon.target_coords:
                self.current_beacon.achieved = True
                if self.on_beacon_achieved:
                    self.on_beacon_achieved(self.current_beacon)
                
                logger.info(f"ðŸŽ¯ Beacon achieved: {self.current_beacon.description}")
                self.mode = DirectorMode.CINEMATIC
                break
        
        # Return to planning
        if self.mode != DirectorMode.PAUSED:
            self.mode = DirectorMode.PLANNING
    
    async def _cinematic_phase(self) -> None:
        """Cinematic phase: Pause for narrative delivery."""
        if not self.current_beacon:
            self.mode = DirectorMode.PLANNING
            return
        
        logger.debug(f"ðŸŽ¬ Cinematic phase: {self.current_beacon.description}")
        
        # Pause for narrative delivery
        await asyncio.sleep(3.0 / self.playback_speed)
        
        # Return to planning
        self.mode = DirectorMode.PLANNING
    
    def _calculate_path_to_beacon(self, start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Calculate deterministic path from start to target.
        
        Simple implementation: straight-line path with obstacle avoidance.
        In a full implementation, this would use A* pathfinding on the tile map.
        """
        # Simple straight-line path for now
        path = []
        current = start
        
        while current != target:
            path.append(current)
            
            # Move one step toward target
            dx = target[0] - current[0]
            dy = target[1] - current[1]
            
            # Determine next step
            if abs(dx) > abs(dy):
                next_x = current[0] + (1 if dx > 0 else -1)
                next_y = current[1]
            elif abs(dy) > 0:
                next_x = current[0]
                next_y = current[1] + (1 if dy > 0 else -1)
            else:
                # Reached target
                break
            
            current = (next_x, next_y)
        
        # Add target as final position
        path.append(target)
        
        return path
    
    def _get_direction_from_movement(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> str:
        """Get direction string from movement vector."""
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]
        
        if dx > 0:
            return "east"
        elif dx < 0:
            return "west"
        elif dy > 0:
            return "south"
        elif dy < 0:
            return "north"
        else:
            return "here"
    
    async def _generate_initial_beacons(self) -> None:
        """Generate initial narrative beacons based on starting context."""
        logger.info("ðŸŽ­ Generating initial narrative beacons")
        
        # Get current context from simulator
        state = self.simulator.get_state()
        if not state:
            return
        
        context = state.get_context_str()
        
        # Generate initial beacons using LLM
        initial_beacons = await self._llm_generate_beacons(context, num_beacons=3)
        
        for beacon_data in initial_beacons:
            beacon = NarrativeBeacon(
                beacon_id=beacon_data['beacon_id'],
                target_coords=beacon_data['target_coords'],
                description=beacon_data['description'],
                priority=beacon_data['priority'],
                intent_type=beacon_data['intent_type']
            )
            
            self.beacon_history.append(beacon)
            
            if self.on_beacon_generated:
                self.on_beacon_generated(beacon)
            
            logger.info(f"ðŸŽ¯ Generated beacon: {beacon.description} at {beacon.target_coords}")
    
    async def _generate_narrative_beacons(self, context: str, num_beacons: int = 3) -> List[Dict[str, Any]]:
        """
        Generate narrative beacons using LLM.
        
        Args:
            context: Current game context
            num_beacons: Number of beacons to generate
            
        Returns:
            List of beacon data dictionaries
        """
        # This would integrate with the LLM to generate narrative beacons
        # For now, return hardcoded beacons based on context
        
        beacons = []
        
        # Generate beacons based on context analysis
        if "tavern" in context.lower():
            beacons.extend([
                {
                    'beacon_id': 'tavern_mystery',
                    'target_coords': (25, 25),
                    'description': 'Investigate the mysterious noise in the tavern corner',
                    'priority': 1,
                    'intent_type': 'investigate'
                },
                {
                    'beacon_id': 'town_square_encounter',
                    'target_coords': (15, 15),
                    'description': 'Meet the mysterious figure in the town square',
                    'priority': 2,
                    'intent_type': 'interact'
                },
                {
                    'beacon_id': 'forest_ruins',
                    'target_coords': (35, 35),
                    'description': 'Explore the ancient forest ruins',
                    'priority': 3,
                    'intent_type': 'explore'
                }
            ])
        elif "town" in context.lower():
            beacons.extend([
                {
                    'beacon_id': 'market_discovery',
                    'target_coords': (20, 20),
                    'description': 'Discover rare goods at the market',
                    'priority': 2,
                    'intent_type': 'trade'
                },
                {
                    'beacon_id': 'guard_intelligence',
                    'target_coords': (10, 10),
                    'description': 'Gather information from the town guard',
                    'priority': 1,
                    'intent_type': 'talk'
                },
                {
                    'beacon_id': 'training_grounds',
                    'target_coords': (30, 30),
                    'description': 'Practice combat skills at the training grounds',
                    'priority': 3,
                    'intent_type': 'train'
                }
            ])
        else:
            # Default beacons
            beacons.extend([
                {
                    'beacon_id': 'exploration',
                    'target_coords': (10, 10),
                    'description': 'Explore the surrounding area',
                    'priority': 5,
                    'intent_type': 'explore'
                },
                {
                    'beacon_id': 'investigation',
                    'target_coords': (5, 5),
                    'description': 'Investigate nearby points of interest',
                    'priority': 4,
                    'intent_type': 'investigate'
                }
            ])
        
        return beacons[:num_beacons]
    
    async def _generate_emergency_beacon(self) -> None:
        """Generate emergency beacon when no beacons are available."""
        logger.warning("âš ï¸ Generating emergency beacon")
        
        emergency_beacon = NarrativeBeacon(
            beacon_id="emergency_explore",
            target_coords=(self.voyager_position[0] + 5, self.voyager_position[1] + 5),
            description="Emergency exploration beacon",
            priority=1,
            intent_type="investigate"
        )
        
        self.beacon_history.append(emergency_beacon)
        self.current_beacon = emergency_beacon
        
        if self.on_beacon_generated:
            self.on_beacon_generated(emergency_beacon)
    
    async def _llm_generate_beacons(self, context: str, num_beacons: int) -> List[Dict[str, Any]]:
        """
        Generate beacons using the LLM.
        
        This would integrate with the ChroniclerEngine to generate narrative-driven goals.
        For now, this is a placeholder implementation.
        """
        # Placeholder for LLM integration
        # In a full implementation, this would:
        # 1. Send context to LLM with beacon generation prompt
        # 2. Parse LLM response for beacon data
        # 3. Validate beacon coordinates and priorities
        
        # For now, use the context-based generation
        return await self._generate_narrative_beacons(context, num_beacons)


class NarrativeConsultation:
    """Record of LLM consultation for beacon generation."""
    
    def __init__(self, timestamp: str, context: str, beacons_generated: List[NarrativeBeacon]):
        self.timestamp = timestamp
        self.context = context
        self.beacons_generated = beacons_generated


# Director factory for dependency injection
class DirectorFactory:
    """Factory for creating Director instances with proper dependencies."""
    
    @staticmethod
    def create_director(simulator: SimulatorHost) -> AutonomousDirector:
        """Create director with simulator dependency."""
        return AutonomousDirector(simulator)
