"""
Autonomous Director - The "Dramatic Director" Controller

ADR 045: The "Dramatic Director" Controller

This service implements the autonomous intent system where the LLM acts as the "Subconscious"
that generates narrative beacons, and the Director orchestrates the Voyager's journey.

The Logic:
- LLM reviews 1,000-year history and decides on long-term goals
- Director generates narrative beacons (target coordinates) on the map
- Voyager pursues beacons deterministically using pathfinding
- Terminal acts as "subtitles" scrolling LLM observations
- GUI provides cinematic camera with focus management

This transforms the system from manual input to autonomous movie production.
"""

import asyncio
import time
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

from loguru import logger

from core.simulator import SimulatorHost, ActionResult
from core.world_map import get_world_map, EnvironmentType
from game_state import GameState


class NarrativeBeacon:
    """
    A narrative beacon represents an AI-generated goal location.
    
    The LLM generates these based on the 1,000-year history and current context.
    """
    
    def __init__(self, beacon_id: str, target_coords: Tuple[int, int], 
                 description: str, priority: int, intent_type: str):
        self.beacon_id = beacon_id
        self.target_coords = target_coords
        self.description = description
        self.priority = priority  # 1=highest, 10=lowest
        self.intent_type = intent_type  # "explore", "interact", "travel", "investigate"
        self.created_at = time.time()
        self.achieved = False


class DirectorMode(Enum):
    """Director operational modes."""
    IDLE = "idle"
    PLANNING = "planning"
    EXECUTING = "executing"
    PAUSED = "paused"
    CINEMATIC = "cinematic"


@dataclass
class DirectorIntent:
    """High-level intent generated by the LLM Director."""
    intent_type: str
    description: str
    target_coords: Optional[Tuple[int, int]] = None
    priority: int = 5
    reasoning: str = ""
    confidence: float = 0.0


class AutonomousDirector:
    """
    The Autonomous Director service.
    
    Acts as the bridge between LLM narrative generation and deterministic Voyager navigation.
    Generates narrative beacons and orchestrates the cinematic experience.
    """
    
    def __init__(self, simulator: SimulatorHost, max_turns: int = 100):
        """
        Initialize the Autonomous Director.
        
        Args:
            simulator: The SimulatorHost instance
            max_turns: Maximum number of turns for the autonomous session
        """
        # Core systems
        self.simulator: SimulatorHost = simulator
        self.world_map = get_world_map()
        
        # Director state
        self.mode: DirectorMode = DirectorMode.PLANNING
        self.current_beacon: Optional[NarrativeBeacon] = None
        self.beacon_history: List[NarrativeBeacon] = []
        self.turn_count: int = 0
        self.max_turns: int = max_turns
        
        # Timing and pacing
        self.playback_speed: float = 1.0
        self.cinematic_pause_duration: float = 2.0
        self.last_action_time: float = 0.0
        
        # Callbacks for external coordination
        self.on_beacon_generated: Optional[Callable[[NarrativeBeacon], None]] = None
        self.on_beacon_achieved: Optional[Callable[[NarrativeBeacon], None]] = None
        
        logger.info("ðŸŽ¬ Autonomous Director initialized")
    
    async def start_autonomous_mode(self) -> None:
        """
        Start the autonomous director mode.
        
        The Director will begin generating narrative beacons and orchestrating
        the Voyager's journey autonomously.
        """
        logger.info("ðŸŽ¬ Starting Autonomous Director Mode")
        
        self.mode = DirectorMode.PLANNING
        self.is_cinematic_mode = True
        
        # Generate initial narrative beacons
        await self._generate_initial_beacons()
        
        # Start the director loop
        asyncio.create_task(self._director_loop())
    
    def pause_cinematic(self) -> None:
        """Pause the cinematic experience."""
        self.is_paused = True
        self.mode = DirectorMode.PAUSED
        
        if self.on_cinematic_pause:
            self.on_cinematic_pause("Cinematic paused by user")
        
        logger.info("â¸ï¸ Cinematic paused")
    
    def resume_cinematic(self) -> None:
        """Resume the cinematic experience."""
        self.is_paused = False
        self.mode = DirectorMode.EXECUTING
        
        if self.on_cinematic_pause:
            self.on_cinematic_pause("Cinematic resumed")
        
        logger.info("â–¶ï¸ Cinematic resumed")
    
    def set_playback_speed(self, speed: float) -> None:
        """Set the playback speed (0.5=slow, 1.0=normal, 2.0=fast)."""
        self.playback_speed = max(0.1, min(5.0, speed))
        logger.info(f"â©ï¸ Playback speed set to {self.playback_speed}x")
    
    def get_voyager_position(self) -> Tuple[int, int]:
        """Get the current Voyager position."""
        # Get position from game state
        state = self.simulator.get_state()
        if state and hasattr(state, 'position'):
            return (state.position.x, state.position.y)
        return self.voyager_position
    
    def get_current_beacon(self) -> Optional[NarrativeBeacon]:
        """Get the currently active narrative beacon."""
        return self.current_beacon
    
    def get_beacon_history(self) -> List['NarrativeBeacon']:
        """Get the history of all beacons."""
        return self.beacon_history
    
    async def _director_loop(self) -> None:
        """Main director loop for autonomous operation."""
        logger.info("ðŸŽ¬ Director loop started")
        
        try:
            while self.mode != DirectorMode.IDLE:
                if self.is_paused:
                    await asyncio.sleep(0.1)
                    continue
                
                # Execute based on current mode
                if self.mode == DirectorMode.PLANNING:
                    await self._planning_phase()
                elif self.mode == DirectorMode.EXECUTING:
                    await self._execution_phase()
                elif self.mode == DirectorMode.CINEMATIC:
                    await self._cinematic_phase()
                
                # Increment turn counter
                self.turn_count += 1
                
                # Control loop speed based on playback speed
                sleep_time = 1.0 / self.playback_speed
                await asyncio.sleep(sleep_time)
                
        except Exception as e:
            logger.error(f"âŒ Director loop error: {e}")
            self.mode = DirectorMode.IDLE
        finally:
            logger.info("ðŸŽ¬ Director loop stopped")
    
    async def _planning_phase(self) -> None:
        """Planning phase: Generate narrative beacons."""
        logger.debug("ðŸ“‹ Planning phase: Generating narrative beacons")
        
        # Generate new beacons periodically
        if len(self.beacon_history) == 0 or self.turn_count % self.beacon_generation_interval == 0:
            # Get current context from simulator
            state = self.simulator.get_state()
            context = state.get_context_str() if state else ""
            await self._generate_narrative_beacons(context)
        
        # Select highest priority beacon
        if self.beacon_history:
            active_beacons = [b for b in self.beacon_history if not b.achieved]
            if active_beacons:
                self.current_beacon = max(active_beacons, key=lambda b: b.priority)
                self.mode = DirectorMode.EXECUTING
                logger.info(f"ðŸŽ¯ Selected beacon: {self.current_beacon.description}")
        
        # If no beacons, generate emergency beacon
        if not self.current_beacon:
            await self._generate_emergency_beacon()
    
    async def _execution_phase(self) -> None:
        """Execution phase: Navigate to current beacon."""
        if not self.current_beacon:
            self.mode = DirectorMode.PLANNING
            return
        
        logger.debug(f"ðŸš¶ Executing phase: Moving to {self.current_beacon.target_coords}")
        
        # Get current Voyager position from game state
        current_pos = self.get_voyager_position()
        beacon_coords = self.current_beacon.target_coords
        
        # For now, use simple path calculation (would integrate with NavigationSystem)
        path = self._calculate_path_to_beacon(current_pos, beacon_coords)
        
        if not path:
            logger.warning(f"âŒ No path found to beacon {self.current_beacon.target_coords}")
            self.current_beacon.achieved = True
            if self.on_beacon_achieved:
                self.on_beacon_achieved(self.current_beacon)
            self.mode = DirectorMode.PLANNING
            return
        
        # Execute path step by step
        for i, next_pos in enumerate(path):
            if self.mode != DirectorMode.EXECUTING:
                break
            
            # Calculate direction from current position to next position
            current_pos = self.get_voyager_position()  # Get fresh position
            direction = self._get_direction_from_movement(current_pos, next_pos)
            action_input = f"I move {direction}"
            
            # Submit action through simulator
            self.simulator.submit_action(action_input)
            
            # Wait for action processing
            await asyncio.sleep(0.5 / self.playback_speed)
            
            # Check if reached beacon
            current_pos = self.get_voyager_position()  # Get updated position
            if current_pos == self.current_beacon.target_coords:
                self.current_beacon.achieved = True
                if self.on_beacon_achieved:
                    self.on_beacon_achieved(self.current_beacon)
                
                logger.info(f"ðŸŽ¯ Beacon achieved: {self.current_beacon.description}")
                self.mode = DirectorMode.CINEMATIC
                break
        
        # Return to planning if not paused
        if self.mode != DirectorMode.PAUSED:
            self.mode = DirectorMode.PLANNING
    
    async def _cinematic_phase(self) -> None:
        """Cinematic phase: Pause for narrative delivery."""
        if not self.current_beacon:
            self.mode = DirectorMode.PLANNING
            return
        
        logger.debug(f"ðŸŽ¬ Cinematic phase: {self.current_beacon.description}")
        
        # Pause for narrative delivery
        await asyncio.sleep(3.0 / self.playback_speed)
        
        # Return to planning
        self.mode = DirectorMode.PLANNING
    
    def _calculate_path_to_beacon(self, start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Calculate deterministic path from start to target.
        
        Simple implementation: straight-line path with obstacle avoidance.
        In a full implementation, this would use A* pathfinding on the tile map.
        """
        # Simple straight-line path for now
        path = []
        current = start
        
        while current != target:
            path.append(current)
            
            # Move one step toward target
            dx = target[0] - current[0]
            dy = target[1] - current[1]
            
            # Determine next step
            if abs(dx) > abs(dy):
                next_x = current[0] + (1 if dx > 0 else -1)
                next_y = current[1]
            elif abs(dy) > 0:
                next_x = current[0]
                next_y = current[1] + (1 if dy > 0 else -1)
            else:
                # Reached target
                break
            
            current = (next_x, next_y)
        
        # Add target as final position
        path.append(target)
        
        return path
    
    def _get_direction_from_movement(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> str:
        """Get direction string from movement vector."""
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]
        
        if dx > 0:
            return "east"
        elif dx < 0:
            return "west"
        elif dy > 0:
            return "south"
        elif dy < 0:
            return "north"
        else:
            return "here"
    
    async def _generate_initial_beacons(self) -> None:
        """Generate initial narrative beacons based on starting context."""
        logger.info("ðŸŽ­ Generating initial narrative beacons")
        
        # Get current context from simulator
        state = self.simulator.get_state()
        if not state:
            return
        
        context = state.get_context_str()
        
        # Generate initial beacons using LLM
        initial_beacons = await self._llm_generate_beacons(context, num_beacons=3)
        
        for beacon_data in initial_beacons:
            beacon = NarrativeBeacon(
                beacon_id=beacon_data['beacon_id'],
                target_coords=beacon_data['target_coords'],
                description=beacon_data['description'],
                priority=beacon_data['priority'],
                intent_type=beacon_data['intent_type']
            )
            
            self.beacon_history.append(beacon)
            
            if self.on_beacon_generated:
                self.on_beacon_generated(beacon)
            
            logger.info(f"ðŸŽ¯ Generated beacon: {beacon.description} at {beacon.target_coords}")
    
    async def _generate_narrative_beacons(self, context: str, num_beacons: int = 3) -> List[Dict[str, Any]]:
        """
        Generate narrative beacons using physical landmarks from the world map.
        
        Args:
            context: Current game context
            num_beacons: Number of beacons to generate
            
        Returns:
            List of beacon data dictionaries
        """
        beacons = []
        
        try:
            # Get current position and environment
            current_pos = self.get_voyager_position()
            current_env = self.world_map.get_current_environment(current_pos[0], current_pos[1])
            
            # Get available landmarks in current environment
            if current_env:
                landmarks = self.world_map.get_landmarks_in_zone(current_env)
                director_landmarks = [lm for lm in landmarks if lm.interaction_type in ["portal", "chest", "npc"]]
                
                # Generate beacons for each landmark
                for landmark in director_landmarks[:num_beacons]:
                    beacon_data = {
                        'beacon_id': f"landmark_{landmark.name.lower().replace(' ', '_')}",
                        'target_coords': landmark.coords,
                        'description': f"Visit {landmark.name}",
                        'priority': 1,
                        'intent_type': 'explore',
                        'reasoning': landmark.description
                    }
                    beacons.append(beacon_data)
                    logger.info(f"ðŸŽ¯ Generated landmark beacon: {landmark.name} at {landmark.coords}")
            
            # If no landmarks in current zone, generate travel beacons
            if len(beacons) < num_beacons:
                for env_type in [EnvironmentType.TOWN_SQUARE, EnvironmentType.TAVERN_INTERIOR, EnvironmentType.FOREST_PATH]:
                    if env_type != current_env and len(beacons) < num_beacons:
                        entry_point = self.world_map.get_zone_entry_point(env_type)
                        if entry_point:
                            zone = self.world_map.zones.get(env_type)
                            beacon_data = {
                                'beacon_id': f"travel_{env_type.value}",
                                'target_coords': entry_point,
                                'description': f"Travel to {zone.name}",
                                'priority': 1,
                                'intent_type': 'travel',
                                'reasoning': f"Entry point to {zone.name}"
                            }
                            beacons.append(beacon_data)
                            logger.info(f"ðŸŽ¯ Generated travel beacon: {zone.name} at {entry_point}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to generate narrative beacons: {e}")
            # Fallback: generate simple exploration beacon
            current_pos = self.get_voyager_position()
            fallback_beacon = {
                'beacon_id': 'explore_fallback',
                'target_coords': (current_pos[0] + 5, current_pos[1] + 5),
                'description': "Explore the area",
                'priority': 1,
                'intent_type': 'explore',
                'reasoning': "Basic exploration directive"
            }
            beacons.append(fallback_beacon)
        
        return beacons
    
    def _select_beacon(self, beacons: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Select the most appropriate beacon from the generated list.
        
        Args:
            beacons: List of beacon data dictionaries
            
        Returns:
            Selected beacon data or None
        """
        if not beacons:
            return None
        
        # For now, select the highest priority (lowest number) beacon
        # In a full implementation, this would consider distance, context, etc.
        return min(beacons, key=lambda b: b['priority'])
    
    def _calculate_path_to_beacon(self, start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Calculate a path from start to target coordinates.
        
        Args:
            start: Starting coordinates
            target: Target coordinates
            
        Returns:
            List of coordinates representing the path
        """
        # Simple straight-line path for now
        # In a full implementation, this would use A* pathfinding
        path = []
        current = start
        
        while current != target:
            # Move one step toward target
            dx = 1 if target[0] > current[0] else -1 if target[0] < current[0] else 0
            dy = 1 if target[1] > current[1] else -1 if target[1] < current[1] else 0
            
            current = (current[0] + dx, current[1] + dy)
            path.append(current)
            
            # Prevent infinite loops
            if len(path) > 100:
                break
        
        return path
    
    def _get_direction_from_movement(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> str:
        """
        Get direction string from movement vector.
        
        Args:
            from_pos: Starting position
            to_pos: Target position
            
        Returns:
            Direction string (north, south, east, west, etc.)
        """
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]
        
        if dx > 0 and dy == 0:
            return "east"
        elif dx < 0 and dy == 0:
            return "west"
        elif dx == 0 and dy > 0:
            return "south"
        elif dx == 0 and dy < 0:
            return "north"
        elif dx > 0 and dy > 0:
            return "southeast"
        elif dx > 0 and dy < 0:
            return "northeast"
        elif dx < 0 and dy > 0:
            return "southwest"
        elif dx < 0 and dy < 0:
            return "northwest"
        else:
            return "here"
                    'target_coords': (5, 5),
                    'description': 'Investigate nearby points of interest',
                    'priority': 4,
                    'intent_type': 'investigate'
                }
            ])
        
        return beacons[:num_beacons]
    
    async def _generate_emergency_beacon(self) -> None:
        """Generate emergency beacon when no beacons are available."""
        logger.warning("âš ï¸ Generating emergency beacon")
        
        emergency_beacon = NarrativeBeacon(
            beacon_id="emergency_explore",
            target_coords=(self.voyager_position[0] + 5, self.voyager_position[1] + 5),
            description="Emergency exploration beacon",
            priority=1,
            intent_type="investigate"
        )
        
        self.beacon_history.append(emergency_beacon)
        self.current_beacon = emergency_beacon
        
        if self.on_beacon_generated:
            self.on_beacon_generated(emergency_beacon)
    
    async def _llm_generate_beacons(self, context: str, num_beacons: int) -> List[Dict[str, Any]]:
        """
        Generate beacons using the LLM.
        
        This would integrate with the ChroniclerEngine to generate narrative-driven goals.
        For now, this is a placeholder implementation.
        """
        # Placeholder for LLM integration
        # In a full implementation, this would:
        # 1. Send context to LLM with beacon generation prompt
        # 2. Parse LLM response for beacon data
        # 3. Validate beacon coordinates and priorities
        
        # For now, use the context-based generation
        return await self._generate_narrative_beacons(context)


class NarrativeConsultation:
    """Record of LLM consultation for beacon generation."""
    
    def __init__(self, timestamp: str, context: str, beacons_generated: List[NarrativeBeacon]):
        self.timestamp = timestamp
        self.context = context
        self.beacons_generated = beacons_generated


# Director factory for dependency injection
class DirectorFactory:
    """Factory for creating Director instances with proper dependencies."""
    
    @staticmethod
    def create_director(simulator: SimulatorHost) -> AutonomousDirector:
        """Create director with simulator dependency."""
        return AutonomousDirector(simulator)
